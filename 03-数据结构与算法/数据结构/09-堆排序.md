---
title: "15 堆排序"
date: 2020-07-01T16:20:52+08:00
draft: true
---

- [0.1. 堆](#01-堆)
  - [0.1.1. 实现堆](#011-实现堆)
    - [0.1.1.1. 存储方式](#0111-存储方式)
    - [0.1.1.2. 往堆中插入一个元素](#0112-往堆中插入一个元素)
    - [0.1.1.3. 删除堆顶元素](#0113-删除堆顶元素)
- [0.2. 基于堆实现排序](#02-基于堆实现排序)
  - [0.2.1. 建堆](#021-建堆)
  - [0.2.2. 排序](#022-排序)
- [0.3. 应用](#03-应用)
  - [0.3.1. 优先级队列](#031-优先级队列)
    - [0.3.1.1. 合并有序小文件](#0311-合并有序小文件)
    - [0.3.1.2. 高性能定时器](#0312-高性能定时器)
  - [0.3.2. 求TopK](#032-求topk)
    - [0.3.2.1. 静态数据](#0321-静态数据)
    - [0.3.2.2. 动态数据](#0322-动态数据)
  - [0.3.3. 求中位数](#033-求中位数)
  - [0.3.4. 求百分位数据](#034-求百分位数据)

堆是一种特殊的数据结构，应用场景很多，堆排序是一种原地排序，时间复杂度`O(nlogn)`。

## 0.1. 堆

堆是一种特殊的树，满足以下两点就是一个堆：

- 堆是一个完全二叉树（除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列）

- 堆中每一个节点的值都必须大于等于（或小于等于）其左右子节点的值
  - 对于每个节点的值都**大于等于**子树中每个节点值的堆，叫作“大顶堆”
  - 对于每个节点的值都**小于等于**子树中每个节点值的堆，叫作“小顶堆”

### 0.1.1. 实现堆

#### 0.1.1.1. 存储方式

堆是完全二叉树比较适合用**数组**来存储。用数组来存储完全二叉树是非常节省存储空间的。因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

![image](/images/4d349f57947df6590a2dd1364c3b0b1e.jpg)

从图中可以看到，数组中下标为 `i` 的节点：

- 左子节点：是下标为 `i∗2` 的节点
- 右子节点：是下标为 `i∗2+1` 的节点
- 父节点：是下标为 $$\frac{i}{2}$$​ 的节点

#### 0.1.1.2. 往堆中插入一个元素

如果往堆尾插入一个元素后，需要继续满足堆的两个特性，这时就需要进行调整，称为**堆化**。堆化有两种：

- 从下往上
- 从上往下

> 堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。

下面的例子是从下往上的堆化。

![image](/images/e578654f930002a140ebcf72b11eb722.jpg)

1. 新插入的节点与父节点对比大小
2. 如果不满足子节点小于等于父节点的大小关系，就互换两个节点
3. 一直重复这个过程，直到父子节点之间满足刚说的那种大小关系

![image](/images/e3744661e038e4ae570316bc862b2c0e.jpg)

#### 0.1.1.3. 删除堆顶元素

根据堆的定义，任何节点的值都大于等于（或小于等于）子树节点的值，所以，堆顶元素存储的就是堆中数据的最大值或者最小值。

假设构造的是大顶堆，堆顶元素就是最大的元素。

1. 当删除堆顶元素后，就需要把第二大的元素放到堆顶
2. 第二大元素肯定会出现在左右子节点中
3. 然后再迭代地删除第二大节点
4. 以此类推
5. 直到叶子节点被删除

![image](/images/5916121b08da6fc0636edf1fc24b5a81.jpg)

出现左侧叶子节点为空的情况，这样的删除思路导致堆不满足完全二叉树的特性。

换一下思路来解决这个问题。

1. 当删除堆顶元素后，把最后一个节点放到堆顶
2. 然后利用同样的父子节点对比方法
3. 对于不满足父子节点大小关系的，互换两个节点
4. 并且重复进行这个过程，直到父子节点之间满足大小关系为止

这就是**从上往下**的堆化方法。

> 因为移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。

![image](/images/110d6f442e718f86d2a1d16095513260.jpg)

一个包含 `n` 个节点的完全二叉树，树的高度不会超过 $$log_2​n$$。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 $$O(logn)$$。

插入数据和删除堆顶元素的主要逻辑就是**堆化**，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 $$O(logn)$$。

## 0.2. 基于堆实现排序

借助于堆这种数据结构实现的排序算法，就叫作**堆排序**，它的时间复杂度非常稳定，是 $$O(nlogn)$$，并且它还是原地排序算法。把堆排序的过程大致分解成两个大的步骤，**建堆**和**排序**。

### 0.2.1. 建堆

首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。建堆的过程，有两种思路。

1. 第一种是按照在堆中插入一个元素的思路。假设起初堆中只包含一个数据，就是下标为 1 的数据。然后，调用插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样就将包含 n 个数据的数组，组织成了堆。这种建堆思路的处理过程是：
   1. **从前往后**处理数组数据
   2. 并且每个数据都是**从下往上**堆化
2. 第二种实现思路，跟第一种截然相反：
   1. **从后往前**处理数组
   2. 并且每个数据都是**从上往下**堆化

举个例子操作第二种实现思路的建堆分解步骤图。因为叶子节点往下堆化只能自己跟自己比较，所以直接从**第一个非叶子节点**开始，依次堆化就行了。

![image](/images/50c1e6bc6fe68378d0a66bdccfff441e.jpg)

![image](/images/aabb8d15b1b92d5e040895589c60419d.jpg)

对于完全二叉树来说，下标从 $$\frac{n}{2}+1$$ 到 n 的节点都是叶子节点，不需要参与堆化的过程，所以对下标从 $$\frac{n}{2}$$ 开始到 1 的数据进行堆化。

每个节点堆化的时间复杂度是 `O(logn)`，$$\frac{n}{2}+1$$个节点堆化的总时间复杂度就是`O(nlogn)`，更精确一点，堆排序的建堆过程的时间复杂度是 `O(n)`。

因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数与该节点的高度 k 成正比。

![image](/images/899b9f1b40302c9bd5a7f77f042542d5.jpg)

将每个非叶子节点的高度求和：

![image](/images/f712f8a7baade44c39edde839cefcc09.jpg)

把公式左右都乘以 2，就得到另一个公式 S2，将 S2 错位对齐，并且用 S2 减去 S1，可以得到 S。

![image](/images/629328315decd96e349d8cb3940636df.jpg)

S 的中间部分是一个等比数列，所以最后可以用等比数列的求和公式来计算。

![image](/images/46ca25edc69b556b967d2c62388b7436.jpg)

因为 $$h=log2_​n$$，代入公式 S，就能得到 `S=O(n)`，所以，建堆的时间复杂度就是 `O(n)`。

### 0.2.2. 排序

建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。

1. 把堆顶元素跟最后一个元素交换，那最大元素就放到了下标为 n 的位置，然后开始堆化。
  
  > 这个过程类似“删除堆顶元素”的操作，当堆顶元素移除之后，把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。

2. 堆化完成之后，再取堆顶的元素，放到下标是 n−1 的位置
3. 一直重复这个过程
4. 直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了

![image](/images/23958f889ca48dbb8373f521708408d1.jpg)

整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是**原地排序算法**。

堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 `O(n)`，排序过程的时间复杂度是 `O(nlogn)`，所以，堆排序整体的时间复杂度是 `O(nlogn)`。

堆排序是**不稳定排序算法**，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。

上面都是假设，堆中的数据是从数组下标为 `1` 的位置开始存储。那如果从 `0` 开始存储，实际上处理思路是没有任何变化的，唯一变化的，可能就是，代码实现的时候，计算子节点和父节点的下标的公式改变了。

如果节点的下标是 `i`，那左子节点的下标就是 `2∗i+1`，右子节点的下标就是 `2∗i+2`，父节点的下标就是 `(i-1)/2`​。

## 0.3. 应用

在实际开发中，快速排序要比堆排序性能好：

1. 堆排序数据访问的方式没有快速排序友好
   1. 对于快速排序来说，数据是顺序访问的（对CPU友好）
   2. 对于堆排序来说，数据是跳着访问的（堆排序中，最重要的一个操作就是数据的堆化）
2. 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序

> 对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，**比较**和**交换**（或移动）。

堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。

### 0.3.1. 优先级队列

优先级队列是一个队列，最大的特性就是先进先出。在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。

实现一个优先级队列方法有很多，用堆来实现是最直接、最高效的。因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。

- 往优先级队列中插入一个元素，就相当于往堆中插入一个元素
- 从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素

优先级队列的应用场景非常多。很多语言中，都提供了优先级队列的实现，比如：

- Java 的 `PriorityQueue`
- C++ 的 `priority_queue`

举两个具体的例子，来感受一下优先级队列。

#### 0.3.1.1. 合并有序小文件

- 假设有 100 个小文件，
- 每个文件的大小是 `100MB`，
- 每个文件中存储的都是有序的字符串

希望将这 100 个小文件合并成一个有序的大文件，使用优先级队列，整体思路有点像归并排序中的合并函数。

1. 从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除
2. 假设，这个最小的字符串来自于 `13.txt` 这个小文件，就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除
3. 依次类推，直到所有的文件中的数据都放入到大文件为止

这里用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。

将数组换成优先级队列（堆）。

1. 将从小文件中取出来的字符串放入到小顶堆中，堆顶的元素就是优先级队列队首的元素，就是最小的字符串
2. 将这个字符串放入到大文件中，并将其从堆中删除
3. 再从小文件中取出下一个字符串，放入到堆中
4. 循环这个过程，将 100 个小文件中的数据依次放入到大文件中

删除堆顶数据和往堆中插入数据的时间复杂度都是 `O(logn)`，`n` 表示堆中的数据个数，这里就是 `100`。

#### 0.3.1.2. 高性能定时器

假设有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。

时间|任务
---|---
2018.11.28.17:30|A
2018.11.28.19:20|B
2018.11.28.15:31|C
2018.11.28.13:55|D

但是，每过 1 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：

- 第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；
- 第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。

针对这些问题，可以用优先级队列来解决。

1. 按照任务设定的执行时间，将这些任务存储在优先级队列中
2. 队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务
3. 定时器就不需要每隔 1 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。这个时间间隔 `T` 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行
4. 这定时器就可以设定在 `T` 秒之后，再来执行任务。从当前时间点到`T-1`秒这段时间里，定时器都不需要做任何事情
5. 当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行
6. 再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间

这样，定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了。

### 0.3.2. 求TopK

把求 Top K 的问题抽象成两类。

- 针对静态数据集合，也就是说数据集合事先确定，不会再变。
- 针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。

#### 0.3.2.1. 静态数据

针对静态数据，在一个包含 n 个数据的数组中，查找前 K 大数据，可以通过维护一个大小为 K 的小顶堆。

1. 顺序遍历数组，从数组中取出数据与堆顶元素比较
2. 如果比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中
3. 如果比堆顶元素小，则不做处理，继续遍历数组

等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。

遍历数组需要 `O(n)` 的时间复杂度，一次堆化操作需要 `O(logK)` 的时间复杂度，所以最坏情况下，`n` 个元素都入堆一次，时间复杂度就是 `O(nlogK)`。

#### 0.3.2.2. 动态数据

针对动态数据求得 Top K 就是实时 Top K。

动态数据集合有两个操作：

- 添加数据
- 询问当前的前 K 大数据

> 如果每次询问前 K 大数据，都基于当前的数据重新计算的话，那时间复杂度就是 `O(nlogK)`，n 表示当前的数据的大小。

实际上，可以一直都维护一个 K 大小的小顶堆：

1. 当有数据被添加到集合中时，拿它与堆顶的元素对比
2. 如果比堆顶元素大，就把堆顶元素删除，并且将这个元素插入到堆中
3. 如果比堆顶元素小，则不做处理

这样，无论何时查询当前的前 K 大数据，都可以立刻返回。

### 0.3.3. 求中位数

求数据集合中的中位数（处在中间位置的那个数），假设数据是从 0 开始编号：

- 如果数据的个数是**奇数**，把数据从小到大排列，那第 $$\frac{n}{2}+1$$ 个数据就是中位数；
- 如果数据的个数是**偶数**，那处于中间位置的数据有两个，第 $$\frac{n}{2}$$ 个和第 $$\frac{n}{2}+1$$ 个数据，任意取一个作为中位数（比如取两个数中靠前的那个，就是第 $$\frac{n}{2}$$ 个数据）

![image](/images/1809157fdd804dd40a6a795ec30acbb6.jpg)

对于一组**静态**数据，中位数是**固定**的，先排序，第 $$\frac{n}{2}$$​ 个数据就是中位数，每次询问中位数的时候，直接返回这个固定的值就好了。**虽然排序的代价比较大，但是边际成本会很小**。

如果面对的是**动态**数据集合，中位数在**不停变动**，每次询问中位数的时候，都要先进行排序，那效率就不高了。
**借助堆可以不排序的情况下，就非常高效地实现求中位数操作**。

维护两个堆：

- 大顶堆：存储前半部分数据
- 小顶堆：存储后半部分数据

**小顶堆中的数据都大于大顶堆中的数据**。

如果有 n 个数据，：

- n 是偶数，从小到大排序，那前 $$\frac{n}{2}$$​ 个数据存储在大顶堆中，后 $$\frac{n}{2}$$​ 个数据存储在小顶堆中。这样，大顶堆中的堆顶元素就是中位数
- n 是奇数，大顶堆就存储 $$\frac{n}{2}+1$$ 个数据，小顶堆中就存储 $$\frac{n}{2}$$ 个数据

![image](/images/08c29d3e014a4baf5f8148c2271e6099.jpg)

数据是动态变化的，当新添加一个数据时调整两个堆，让大顶堆中的堆顶元素继续是中位数：

1. 如果新加入的数据小于等于大顶堆的堆顶元素，就将这个新数据插入到大顶堆
2. 否则，就将这个新数据插入到小顶堆

这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况：

- n 是偶数，两个堆中的数据个数都是 $$\frac{n}{2}$$
- n 是奇数，大顶堆有 $$\frac{n}{2}+1$$ 个数据，小顶堆有 $$\frac{n}{2}$$ 个数据

这个时候，可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。

![image](/images/aee4dcaf9d34111870a1d66a6e109fb1.jpg)

于是，就可以利用两个堆，一个大顶堆、一个小顶堆，实现在动态数据集合中求中位数的操作。插入数据因为需要涉及堆化，所以时间复杂度变成了 `O(logn)`，但是求中位数只需要返回大顶堆的堆顶元素就可以了，所以时间复杂度就是 `O(1)`。

### 0.3.4. 求百分位数据

利用两个堆快速求其他百分位的数据，原理与求中位数类似。

如何快速求接口的99%的响应时间？

- 中位数的概念就是将数据从小到大排列，处于中间位置，就叫中位数，这个数据会大于等于前面 50% 的数据。
- 99百分位数的概念可以类比中位数，如果将一组数据从小到大排列，这个 99 百分位数就是大于前面 99% 数据的那个数据。

> 如果有 100 个接口访问请求，每个接口请求的响应时间都不同，比如 55 毫秒、100 毫秒、23 毫秒等，把这 100 个接口的响应时间按照从小到大排列，排在第 99 的那个数据就是 99% 响应时间，也叫 99 百分位响应时间。

如果有 n 个数据，将数据从小到大排列之后，99 百分位数大约就是第 `n*99%` 个数据，同类，80 百分位数大约就是第 `n*80%` 个数据。

假设当前总数据的个数是 n，求 99% 响应时间，只需要维护两个堆：

- 大顶堆：保存 `n*99%` 个数据
- 小顶堆：保存 `n*1%` 个数据

大顶堆堆顶的数据就是要找的 99% 响应时间。

每次插入一个数据时，要判断这个数据跟大顶堆和小顶堆堆顶数据的大小关系，然后决定插入到哪个堆中。

- 如果这个新插入的数据比大顶堆的堆顶数据小，那就插入大顶堆
- 如果这个新插入的数据比小顶堆的堆顶数据大，那就插入小顶堆

为了保持大顶堆中的数据占 99%，小顶堆中的数据占 1%，在每次新插入数据之后，要重新计算大顶堆和小顶堆中的数据个数，是否还符合 99:1 这个比例。如果不符合，就将一个堆中的数据移动到另一个堆，直到满足这个比例。

通过这样的方法，每次插入数据，可能会涉及几个数据的堆化操作，所以时间复杂度是 `O(logn)`。每次求 99% 响应时间的时候，直接返回大顶堆中的堆顶数据即可，时间复杂度是 `O(1)`。
