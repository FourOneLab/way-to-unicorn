---
title: "05 队列"
date: 2020-06-21T09:49:59+08:00
draft: true
---

- [0.1. 顺序队列和链式队列](#01-顺序队列和链式队列)
- [0.2. 循环队列](#02-循环队列)
- [0.3. 阻塞队列和并发队列](#03-阻塞队列和并发队列)
- [0.4. 应用](#04-应用)

**先进者先出，这就是典型的“队列”**，最基本的操作也是两个：

- **入队 `enqueue()`**，放一个数据到队列尾部
- **出队 `dequeue()`**，从队列头部取一个元素

队列跟栈一样，也是一种**操作受限的线性表数据结构**。

## 0.1. 顺序队列和链式队列

队列可以用数组来实现，也可以用链表来实现。

- 用数组实现的队列叫作**顺序队列**
- 用链表实现的队列叫作**链式队列**

相比于栈只需要一个栈顶指针，队列需要两个指针:

- `head`指针：指向队头
- `tail`指针：指向队尾

随着不停地进行入队、出队操作，`head` 和 `tail` 都会持续往后移动。当 `tail` 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。因此需要进行**数据搬移**，每次进行出队操作都相当于删除数组下标为 0 的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的 `O(1)` 变为 `O(n)`。

**实际上，在出队时可以不用搬移数据。如果没有空闲空间了，只需要在入队时，再集中触发一次数据的搬移操作**。

当队列的 `tail` 指针移动到数组的最右边后，如果有新的数据入队，可以将 `head` 到 `tail` 之间的数据，整体搬移到数组中 0 到 `tail-head` 的位置。

![image](/images/094ba7722eeec46ead58b40c097353c7.jpg)

这种实现思路中，出队操作的时间复杂度仍然是 `O(1)`，但入队操作的时间复杂度还是 `O(1)`。

基于链表的实现，同样需要两个指针：`head` 指针和 `tail` 指针。它们分别指向链表的第一个结点和最后一个结点。

如图所示：

- 入队时，`tail->next= new_node`, `tail = tail->next`
- 出队时，`head = head->next`

![image](/images/c916fe2212f8f543ddf539296444d393.jpg)

## 0.2. 循环队列

使用数组实现队列时，当`tail==n`，会有数据搬移操作，这样入队操作的性能会受到影响。可以使用循环队列解决这个问题。

原本数组是有头有尾的，是一条直线。现在把首尾相连，扳成了一个环。如下图所示：

![image](/images/58ba37bb4102b87d66dffe7148b0f990.jpg)

1. 图中队列的大小为 `8`，当前 `head=4`，`tail=7`。
2. 当有一个新的元素 `a` 入队时，放入下标为 `7` 的位置。此时，不把 `tail` 更新为 8，而是将其在环中后移一位，到下标为 `0` 的位置。
3. 当再有一个元素 `b` 入队时，将 `b` 放入下标为 `0` 的位置，然后 `tail` 加 `1` 更新为 `1`。

在 `a`，`b` 依次入队之后，循环队列中的元素就变成如下图所示：

![image](/images/71a41effb54ccea9dd463bde1b6abe80.jpg)

这样可以避免**数据搬移**操作。循环队列实现的关键是，**确定好队空和队满的判定条件**。

- 数组实现的非循环队列中，
  - 队满的判断条件是 `tail == n`
  - 队空的判断条件是 `head == tail`
- 数组实现的循环队列中，
  - 队满的判断条件是 `（tail + 1）%n == head`
  - 队空的判断条件是 `head == tail`

当队满即`(tail+1)%n=head`时，`tail` 指向的位置实际上是没有存储数据的。所以，**循环队列会浪费一个数组的存储空间**。

## 0.3. 阻塞队列和并发队列

一些具有特殊特性的队列在实际开发中应用广泛，如阻塞队列和并发队列。

- **阻塞队列**：在队列基础上增加了阻塞操作，
  - 在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回
  - 如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回

![image](/images/5ef3326181907dea0964f612890185eb.jpg)

可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”，这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地**协调生产和消费的速度**。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。

基于阻塞队列，还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。如配置多个“消费者”，来应对一个“生产者”。

![image](/images/9f539cc0f1edc20e7fa6559193898067.jpg)

在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，线程安全的队列叫作**并发队列**。

1. 最简单直接的实现方式是直接在 `enqueue()`、`dequeue()` 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。
2. 基于数组的循环队列，利用 CAS（compare and swap，比较并交换） 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。

> 比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。

## 0.4. 应用

> CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，**过多的线程反而会导致 CPU 频繁切换，处理性能下降**。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。

当线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？一般有两种处理策略。

1. 第一种是**非阻塞**的处理方式，直接拒绝任务请求；
2. 另一种是**阻塞**的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。

如何存储排队的请求呢？我们希望公平地处理每个排队的请求，**先进者先服务**，所以队列这种数据结构很适合来存储排队请求。

队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？

- 基于链表的实现方式，可以实现一个支持无限排队的**无界队列**（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对**响应时间比较敏感的系统**，基于链表实现的无限排队的线程池是不合适的。
- 基于数组实现的**有界队列**（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。**设置一个合理的队列大小**，也是非常有讲究的：
  - 队列太大导致等待的请求太多
    - 队列太小会导致无法充分利用系统资源、发挥最大性能

队列应用在线程池请求排队的场景，队列也可以应用在**任何有限资源池**中，用于排队请求，比如数据库连接池等。

**实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队**。
