# 程序实体

Go语言中的程序实体包括：

- 变量
- 常量
- 函数
- 结构体
- 接口

Go语言是**静态类型**的编程语言，需要在声明**变量**和**常量**的时候，指定它们的类型或给予足够的信息，让Go语言能够推导出它们的类型。

- 变量的合法类型：
  1. Go语言预定义的类型
  2. 自定义的函数、结构体、接口

- 常量的合法类型：
  1. Go语言预定义的基本类型

## 变量

```go
// 变量声明方式的不同方式

var name string

var name="string"   // 类型推断 【编程语言在编译期自动解释表达式类型的能力】
                    // 表达式类型是对表达式求值后得到结果的类型
                    // 类型推断只能用于变量或常量的初始化

name := "string"    // 短变量声明 【只能在函数体内部使用】，也属于类型推断
```

### 类型推断的好处

类型推断在编译期执行，对程序的运行效率没有影响。

1. 代码重构：通常把不改变某个程序与外界的任何交互方式和规则，而只改变内部实现的代码修改方式，重构对象（代码、函数、模块、系统），可以随意修改被重构部分的代码，而不影响调用它的部分。

> 不显式地指定变量或常量的类型，使得它可以被赋予任何类型的值，变量的类型在初始化的时候，由程序动态确定。

**Go是静态类型语言，所以一点初始化变量是确定了类型，之后就不能再改变**。

### 变量的重声明

使用短变量声明，可以对统一代码块中的变量进行重声明。

代码块的含义：

1. 全域代码块
2. 代码包
3. 源文件
4. 函数
5. if、for、switch、select、case语句
6. 空代码块

变量重声明的前提：

1. 变量的类型在初始化时已经确定，重声明的类型必须与元类型相同，否则产生编译错误
2. 变量的重声明只能发生在某一个代码块
3. 变量的重声明只有使用短变量声明是才会发生，否则无法通过编译
4. 声明并赋值的变量必须是多个，并且其中至少有一个是新的变量

**使用短变量声明时可不用判断在意被赋值的多个变量中是否包含旧变量**。

### 代码块

作用域：

1. 包级私有：代码包，代码块
2. 模块级私有：代码包，代码块
3. 公开：全域代码块

**一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制**。

1. 代码引用变量的时候，总是会优先查找当前代码块中的变量，不包含子代码块。
2. 如果当前代码块中没有声明以此为名的变量，那么程序沿着代码块的嵌套关系，从直接包含的当前块开始，一层一层地查找。

> 不会查找代码导入的其他包，除非代码包导入语句如下`import . XXX`,这表示让XXX包中公开的程序实体被视为当前源码文件中的实体。

**不同代码块中的可重名变量与变量重声明中的变量的区别：**
| 差异     | 变量重声明                 | 可重名变量                 |
| -------- | -------------------------- | -------------------------- |
| 代码块   | 统一代码块                 | 不同代码块                 |
| 数量     | 只有一个变量               | 多个变量                   |
| 变量类型 | 类型不可变，与初始化时相同 | 类型任意                   |
| 变量屏蔽 | 无                         | 代码块嵌套，则出现变量屏蔽 |

### 判断变量类型

- 类型断言表达式：`x.(T)`,x代表要判断类型的值
- 类型转换表达书：`T(x)`,x源值，x的类型是源类型，T目标类型

在Go语言中`Interface{}`代表空接口，任何类型都是它的实现类型。Interface{}(x),将x转换为空接口的值。

> {}的含义，空代码块或者空数据类型。

```go
value,ok := interface{}(container).([]string)  //value：类型转换后的值，ok：断言是否成功

// value,ok := interface{}(<变量>).(<变量类型>)

// interface{}（<变量>），将变量的值转换为空接口的值
// .(<变量类型>)，判断前者类型是否为变量类型
```

**类型转换规则注意事项：**

1. 类型转换表达式`T(x)`中，x可以使变量，代表值的字面量，结果只有一个值的表达式
2. 类型转换的合法性，大范围转为小范围会被截取
3. 整数转string，如果对应的整数无有效的unicode代码点，转换后变成�，在Unicode中专门替换未知的，不被认可的，无法展示的字符
4. string类型与切片类型之间的互转：
   1. string->[]byte:UTF-8字符串被拆分为ASCII字节
   2. string->[]rune:UTF-8字符串被拆分为Unicode字符

### 别名类型&潜在类型

关键字type声明自定义的各种类型，这些类型必须在Go语言基本类型和高级类型之内。

#### 别名类型

```go
type MyString = string
// MyString是string的别名类型，只是名称有差别，只要用于代码重构
```

- byte是uint8的别名类型
- rune是int32的别名类型

#### 潜在类型

```go
type Mystring2 string   // 对类型在定义

// Mystring2是一个新的类型

// 此处string成为潜在类型
```

1. 潜在类型相同的不同类型的值之间可以进行类型转换
2. 潜在类型相同的不同类型的值之间不能判等
