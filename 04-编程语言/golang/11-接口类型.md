# 接口类型

接口类型与其他数据类型不同，它没法被实例化。既不能通过调用`new()`或`make()`函数创建出一个接口类型的值，也无法用字面量来表示一个接口类型的值。

**对于某一个接口类型，如果没有任何数据类型可以作为它的实现，那么该接口的值就不可能存在**。

接口类型的类型字面量与结构体类型看起来相似，用花括号包裹一些核心信息：

- 结构体类型：包裹**字段声明**
- 接口类型：包裹**方法定义**

> 接口类型声明中的方法代表的就是该接口的方法集合，一个接口的方法集合就是它的全部特征。

**对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征，那么它就一定是这个接口的实现类型**，如下所示：

```go
type Pet interface {
    SetName(name string)
    Name() string
    Category() string
}
// 只要一个数据类型的方法集合中有上述3个方法，那它就是Pet接口的实现类型
// 这是一种无侵入式的接口实现方式
```

**判断一个数据类型的某个方法实现的是某个接口类型中的方法：**

1. 两个方法的**签名**要完全一致
2. 两个方法的**名称**要完全一致

## 专有名词

- 动态值：赋给接口类型的变量的值叫做实际值（动态值）
- 动态类型：被赋予给接口类型的变量的值的类型称为接口类型变量的实际类型（动态类型）

```go
dog := Dog{"little pig"}
var pet Pet = &dog
// &dog是动态值，*dog是动态类型
// pet的类型是静态类型
```

pet的静态类型永远不变，而动态类型会随着赋值的变化而变化。在给一个接口类型的变量赋予实际值之前，它的动态类型是不存在的。

## 给接口变量赋值

**如果使用一个变量给另外一个变量赋值，那么真正赋值给后者的，并不是前者持有的那个值，而是该值的一个副本**。

### 接口类型值的存储方式和结构

接口类型本身是无法被值化的，在赋予接口变量动态值之前，它的值一定是`nil`（它的零值）。当给接口变量赋值时，该变量的动态类型和动态值一起被存储在一个**专用的数据结构(iface)中**。这个接口变量的值其实是这个专用数据结构的实例，而不是赋予给接口变量的那个动态值。

**所以接口变量与动态值肯定是不同的**，无论是存储的内容还是存储的结构都不同。

> 专用数据结构（iface）实例会包含两个指针，一个是指向类型信息（这里的类型信息有另一个专用数据结构的实例承载，包含动态类型以及使他实现了接口的方法和调用它们的途径）的指针，另一个是指向动态值的指针。

## 接口变量的值在什么情况下才真正为nil

```go
var dog1 *Dog       // 声明*Dog类型的变dog1，没有初始化，dog1的值为nil
fmt.Println("The first dog is nil. ")
dog2 := dog1        // dog2的值也为nil
fmt.Println("The second dog is nil. ")
var pet Pet = dog2  // pet的动态值不为nil，pet的动态类型为*Dog
if pet == nil {
    fmt.Println("The pet is nil. ")
} else {
    fmt.Println("The pet is not nil. ")
}
// dog2的值是真正的nil，把dog2赋值给pet时，Go语言把值和类型放在一起考虑
// 因此pet的动态值不是nil
// Go语言识别出赋予pet的值是一个*Dog类型的nil值，
// Go语言用iface的实例包装它，包装后pet的值肯定不是nil
```

> 在Go语言中，把字面量为nil表示的值叫做无类型的nil，这是真正的nil，它的类型也是nil。

**把一个有类型的nil值赋给接口变量，那么这个变量的值一定不会是那个真正的nil**。

让接口变量的值为真正的nil的方法：

1. 只声明接口变量但不初始化
2. 直接把字面量nil赋予给接口变量

## 接口之间的组合

接口类型之间的嵌入称为接口的组合，与结构体类型的组合相比，接口类型组合不会出现方法之间的屏蔽。**只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名不同也不行**。

与结构体组合相似，把接口类型的名称直接写到另一个接口类型的成员类别中，如下所示：

```go
type Animal interface {
    ScientificName() string
    Category() string
}

type Pet interface {
    Animal      // 嵌入
    Name() string
}
// Animal接口包含的所以方法成为了Pet接口的方法
```

> Go语言团队鼓励声明体量较小的接口，并建议通过接口组合来扩展程序、增加程序的灵活性。相比于包含很多方法的大接口，小接口可以专用地表达某一种能力或某一类特征，也更容易被组合在一起。

## 为什么要使用接口

> 在任一编程语言中，接口（方法或行为的集合），在功能和该功能的使用者之间构建了一层薄薄的抽象层。在使用接口时，并不需要了解底层函数是如何实现的，因为接口隔离了各个部分。**跟不使用接口相比，使用接口的最大好处就是可以使代码变得简洁**。

### 构造函数

很多编程语言都有构造函数。构造函数是定义自定义类型（即，面向对象语言中的类）时使用的一种建立对象的方法，它可以确**保必须执行的任何初始化逻辑均已执行**。

> 然而Go语言没有构造函数这么一说。约定俗成就是写一个New函数。

```go
package widget

type Widget struct {
	id string
}

func (w Widget) ID() string {
	return w.id
}

package main

import (
	"fmt"

	"github.com/Promacanthus/vigour/widget"
)

func main() {
	w := widget.Widget{}
	fmt.Println(w.ID())
}
// output
// 空字符串
```

在这里是输出的是空字符串，因为实例化w的时候，ID并没有被初始化，那么它就是字符串类型的零值，也就是空字符串，这不是我们想要的结果。可以在widget包中增加New函数来充当构造函数，完成实例化对象时的初始化操作。

```go
package widget

import "github.com/google/uuid"

type Widget struct {
	id string
}

func NewWidget() Widget {
	return Widget{id: uuid.New().String()}
}

func (w Widget) ID() string {
	return w.id
}

package main

import (
	"fmt"

	"github.com/Promacanthus/vigour/widget"
)

func main() {
	w := widget.NewWidget()
	fmt.Println(w.ID())
}

// output
6608a452-ed5f-4473-84dc-b4f3e77c470d
```

这样实例化w的时候，调用New函数就完成了必要的初始化操作，但是与其他编程语言不同，这里的New函数不是一个强制执行操作而只是一个可选操作。进一步修改，Widget修改为包内类型（也就是该位小写widget），那就只能通过New函数来实例化了，虽然编译器不会报错。

> 其他编程语言中，**类**是复用的基本单位，而在Go语言中，**包**是复用的基本单位。任何无法被包外部访问的内容实质上都是私有的，是这个包内部的实现细节，在使用`godoc`工具生成说明文档的时候，不会为私有函数和类型生成文档的。

唯一的解决方案就是使用接口，通过创建一个外部可访问的Widget接口，并使用包内私有的widget类型实现这个接口，New函数返回一个公开的类型实例，同时`godoc`工具也能够生成文档。

```go
package widget

import "github.com/google/uuid"

// Widget 接口说明
type Widget interface {
	ID() string
}

type widget struct {
	id string
}

// NewWidget 返回一个新建的 Widget 实例
func NewWidget() Widget {
	return widget{id: uuid.New().String()}
}

func (w widget) ID() string {
	return w.id
}

package main

import (
	"fmt"

	"github.com/Promacanthus/vigour/widget"
)

func main() {
	w := widget.NewWidget()
	fmt.Println(w.ID())
}

// output
3207ae37-2256-4ba3-91f6-9c63d9e29120
```

总结一下就是，我们有一个类型，需要用户在实例化的时候使用该类提供的New函数（构造函数）进行初始化，第一步将类型私有化，第二步暴露一个接口类型（包含这个类型的全部方法，这样就实现了这个接口），New函数返回这个接口类型。这样就得到了效果。
