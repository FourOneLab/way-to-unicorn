# 基本并发原语

> 一旦数据被多个线程共享，很可能会产生争用和冲突的情况，这种情况称为**竞态条件（race condition）**，这往往会破坏共享数据的一致性。

**共享数据的一致性代表着：多个线程对共享数据的操作总是可以达到它们各自预期的效果**。

同步的用途有两个：

1. 避免多个线程，在同一时刻操作同一个**数据块**
2. 协调多个线程，避免它们在同一时刻执行同一个**代码块**

这些数据块和代码块的背后都隐含着一种或多种资源（如存储资源，计算资源、I/O资源、网络资源等），把它们看成是共享资源，**同步其实就是在控制多个线程对共享资源的访问**。

## Mutex

常见并发访问问题：

- 多个 goroutine 并发更新同一个资源，像计数器；
- 同时更新用户的账户信息；
- 秒杀系统；
- 往同一个 buffer 中并发写入数据等。

如果没有互斥控制，就会出现一些异常情况，比如计数器的计数不准确、用户的账户可能出现透支、秒杀系统出现超卖、buffer 中的数据混乱，等等，后果都很严重。

### 互斥锁的实现机制

互斥锁（排它锁）是并发控制的一个基本手段，是为了避免竞争而建立的一种并发控制机制。在并发编程中，如果程序中的一部分会被并发访问或修改，那么，为了避免并发访问导致的意想不到的结果，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做临界区。

临界区就是一个被共享的资源，或者说是一个整体的一组共享资源，比如对数据库的访问、对某一个共享数据结构的操作、对一个 I/O 设备的使用、对一个连接池中的连接的调用，等等。

同一个共享资源的相关临界区：

1. 它们可以是一个内含了共享数据的结构体及其方法，
2. 也可以是操作同一块共享数据的多个函数。

使用互斥锁，限定临界区只能同时由一个线程持有。当临界区由一个线程持有的时候，其它线程如果想进入这个临界区，就会返回失败，或者是等待。直到持有的线程退出临界区，这些等待线程中的某一个才有机会接着持有这个临界区。

Mutex（mutual exclusion） 是使用最广泛的同步原语（Synchronization primitives），关于同步原语，可以把它看作解决并发问题的一个基础的数据结构。

同步原语的适用场景：

- 共享资源。并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要 Mutex、RWMutex 这样的并发原语来保护。
- 任务编排。需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，我们常常使用 WaitGroup 或者 Channel 来实现。
- 消息传递。信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 Channel 来实现。

### Mutex使用

在 Go 的标准库中，package sync 提供了锁相关的一系列同步原语，这个 package 还定义了一个 Locker 的接口，Mutex 就实现了这个接口。

Locker 的接口定义了锁同步原语的方法集：

```go
type Locker interface {
    Lock()
    Unlock()
}
```

Go 定义的锁接口的方法集很简单，就是请求锁（Lock）和释放锁（Unlock）这两个方法，秉承了 Go 语言一贯的简洁风格。但是，这个接口在实际项目应用得不多，一般会直接使用具体的同步原语，而不是通过接口。

临界区总是需要受到保护，否则就会产生竞态条件，施加保护的重要手段之一，就是**使用实现了某种同步机制的工具**，称为同步原语。

![临界区](/images/sync.png)

一个互斥锁可以被用来包含一个临界区或者一组相关临界区，通过它来保证在同一时刻只有一个goroutine处于该临界区内。每当有goroutine想进入临界区时，都需要先对它进行锁定，离开时要及时进行解锁。

- 锁定操作可以通过调用互斥锁的Lock方法实现
- 解锁操作可以通过调用互斥锁的Unlock方法实现

```go
func(m *Mutex)Lock()
func(m *Mutex)Unlock()
```

**当一个 goroutine 通过调用 Lock 方法获得了这个锁的拥有权后，其它请求锁的 goroutine 就会阻塞在 Lock 方法的调用上，直到锁被释放并且自己获取到了这个锁的拥有权。**

```go
import (
        "fmt"
        "sync"
    )

func main() {
    var count = 0
    // 使用WaitGroup等待10个goroutine完成
    var wg sync.WaitGroup
    wg.Add(10)
    for i := 0; i < 10; i++ {
        go func() {
            defer wg.Done()
            // 对变量count执行10万次加1
            for j := 0; j < 100000; j++ {
                count++
            }
        }()
    }
    // 等待10个goroutine完成
    wg.Wait()
    fmt.Println(count)
}
// 期望的结果：10 * 100000 = 1000000 (一百万)
// 实际的输出：637887 或者 641893 或者 1000000
```

从上面可以看到，每次运行的结果都不一样，因为count++不是一个原子操作，它至少包含几个步骤，比如读取变量 count 的当前值，对这个值加 1，把结果再保存到 count 中。因为不是原子操作，就可能有并发的问题。

```assembly
// count++操作的汇编代码
MOVQ    "".count(SB), AX
LEAQ    1(AX), CX
MOVQ    CX, "".count(SB)
```

上面这个问题还是比较容易发现，但是，很多时候，并发问题隐藏得非常深，即使是有经验的人，也不太容易发现或者 Debug 出来。

针对这个问题，Go 提供了一个检测并发访问共享资源是否有问题的工具：[race detector](https://blog.golang.org/race-detector)，它可以帮助我们自动发现程序有没有 data race 的问题。

> Go race detector 是基于 Google 的 C/C++ [sanitizers](https://github.com/google/sanitizers) 技术实现的，编译器通过探测所有的内存访问，加入代码能监视对这些内存地址的访问（读还是写）。在代码运行的时候，race detector 就能监控到对共享变量的非同步访问，出现 race 的时候，就会打印出警告信息。这个技术在 Google 内部帮了大忙，探测出了 Chromium 等代码的大量并发问题。Go 1.1 中就引入了这种技术，并且一下子就发现了标准库中的 42 个并发问题。现在，race detector 已经成了 Go 持续集成过程中的一部分。

在编译（compile）、测试（test）或者运行（run）Go 代码的时候，加上 race 参数，就有可能发现并发问题。

比如在上面的例子中，加上 race 参数运行，检测一下是不是有并发问题。执行 `go run -race main.go`，就会输出警告信息。

```bash
go run -race main.go
==================
WARNING: DATA RACE
Read at 0x00c0000b0020 by goroutine 8:
  main.main.func1()
      main.go:16 +0x78

Previous write at 0x00c0000b0020 by goroutine 7:
  main.main.func1()
      main.go:16 +0x91

Goroutine 8 (running) created at:
  main.main()
      main.go:13 +0xe4

Goroutine 7 (running) created at:
  main.main()
      main.go:13 +0xe4
==================
376733
Found 1 data race(s)
exit status 66
```

这个警告不但会告诉你有并发问题，而且还会告诉你哪个 goroutine 在哪一行对哪个变量有写操作，同时，哪个 goroutine 在哪一行对哪个变量有读操作，就是这些并发的读写访问，引起了 data race。

> 虽然这个工具使用起来很方便，但是，因为它的实现方式，只能通过真正对实际地址进行读写访问的时候才能探测，所以它并不能在编译的时候发现 data race 的问题。而且，在运行的时候，只有在触发了 data race 之后，才能检测到，如果碰巧没有触发，是检测不出来的。**而且，把开启了 race 的程序部署在线上，还是比较影响性能的。**

运行 `go tool compile -race -S main.go`，通过在编译的时候插入一些指令，在运行时通过这些插入的指令检测并发读写从而发现 data race 问题，就是这个工具的实现机制。

查看计数器例子的代码，重点关注一下 `count++` 前后的编译后的代码：

```bash
0x0063 00099 (main.go:15)       MOVQ    AX, "".j+8(SP)
0x0068 00104 (main.go:16)       MOVQ    "".&count+128(SP), AX
0x0070 00112 (main.go:16)       MOVQ    AX, (SP)
0x0074 00116 (main.go:16)       CALL    runtime.raceread(SB)
0x0079 00121 (main.go:16)       MOVQ    "".&count+128(SP), AX
0x0081 00129 (main.go:16)       MOVQ    (AX), CX
0x0084 00132 (main.go:16)       MOVQ    CX, ""..autotmp_8+16(SP)
0x0089 00137 (main.go:16)       MOVQ    AX, (SP)
0x008d 00141 (main.go:16)       CALL    runtime.racewrite(SB)
0x0092 00146 (main.go:16)       MOVQ    ""..autotmp_8+16(SP), AX
0x0097 00151 (main.go:16)       INCQ    AX
0x009a 00154 (main.go:16)       MOVQ    "".&count+128(SP), CX
0x00a2 00162 (main.go:16)       MOVQ    AX, (CX)
0x00a5 00165 (main.go:15)       MOVQ    "".j+8(SP), AX

```

在编译的代码中，增加了 `runtime.racefuncenter`、`runtime.raceread`、`runtime.racewrite`、`runtime.racefuncexit` 等检测 data race 的方法。通过这些插入的指令，Go race detector 工具就能够成功地检测出 data race 问题了。

要解决data race就可以使用Mutex。这里的共享资源是 count 变量，临界区是 `count++`，只要在临界区前面获取锁，在离开临界区的时候释放锁，就能完美地解决 data race 的问题了。

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    // 互斥锁保护计数器
    var mu sync.Mutex
    // 计数器的值
    var count = 0
    // 辅助变量，用来确认所有的goroutine都完成
    var wg sync.WaitGroup
    wg.Add(10)
    // 启动10个gourontine
    for i := 0; i < 10; i++ {
        go func() {
            defer wg.Done()
            // 累加10万次
            for j := 0; j < 100000; j++ {
                mu.Lock()
                count++
                mu.Unlock()
            }
        }()
    }
    wg.Wait()
    fmt.Println(count)
}
```

> 注意：Mutex 的零值是还没有 goroutine 等待的未加锁的状态，所以不需要额外的初始化，直接声明变量（如 `var mu sync.Mutex`）即可。

很多情况下，**Mutex 会嵌入到其它 struct 中使用**，或者**采用嵌入字段的方式**，直接在struct上调用Lock/Unlock方法。

```go
package main

import (
	"fmt"
	"sync"
)

type Counter struct {
	sync.Mutex
	count int
}

func main() {
	var (
		counter Counter
		wg      sync.WaitGroup
	)

	wg.Add(10)
	for i := 0; i < 10; i++ {
		go func() {
			defer wg.Done()
			for j := 0; j < 100000; j++ {
				counter.Lock()
				counter.count++
				counter.Unlock()
			}
		}()
	}
	wg.Wait()
	fmt.Println(counter.count)
}
```

如果嵌入的 struct 有多个字段，我们一般会把 Mutex 放在要控制的字段上面，然后使用空格把字段分隔开来，这是一种很好的代码风格，逻辑会更清晰，也更易于维护。

甚至可以**把获取锁、释放锁、计数加一的逻辑封装成一个方法**，对外不需要暴露锁等逻辑：

```go
package main

import (
	"fmt"
	"sync"
)

// 线程安全的计数器类型
type Counter struct {
	CounterType string
	CounterName string

	mu    sync.Mutex
	count uint64
}

// count变量+1
func (c *Counter) AddOne() {
	c.mu.Lock()
	c.count++
	c.mu.Unlock()
}

// 获取count变量的值
func (c *Counter) GetCount() uint64 {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.count
}

func main() {
	var (
		counter Counter
		wg      sync.WaitGroup
	)

	wg.Add(10)
	for i := 0; i < 10; i++ {
		go func() {
			defer wg.Done()
			for j := 0; j < 100000; j++ {
				counter.AddOne()
			}
		}()
	}
	wg.Wait()
	fmt.Println(counter.GetCount())
}

```

#### 注意事项

- 不要重复锁定互斥锁：

> 对于一个已经锁定的互斥锁进行锁定，会立即阻塞当前的goroutine，这个goroutine执行的流程会一直停滞在调用该互斥锁的Lock方法的那行代码上。直到互斥锁的Unlock方法被调用，并且这里的锁定操作成功之后，临界区的代码才会执行。

- 不要忘记解锁互斥锁，必要时使用defer语句

> 可以避免出现重复锁定。因为忘记解锁会使得其他goroutine无法进入到互斥锁保护的临界区中，轻则功能失效，重则死锁崩溃。程序的流程可以分叉也可以被中断，所以一个流程在锁定某个互斥锁之后，紧跟着defer语句进行解锁是比较稳妥的。

- 不要对尚未锁定或者已解锁的互斥锁解锁

> 解锁未锁定的互斥锁会立即引起panic。与死锁的panic一样，无法被恢复。**因此对于每一个锁定操作有且只有一个对应的解锁操作**。

- 不要在多个函数之间直接传递互斥锁

Go语言中的互斥锁是开箱即用的，声明一个`sync.Mutex`类型（该类型是一个**结构体**类型，属于**值类型**）的变量就可以直接使用了。

对于值类型的操作，把它传给一个函数，将它从函数中返回，把它赋给其他变量，让它进入某个通道都会导致它的副本的产生。**原值与副本、副本与副本之间都是完全独立的，它们都是不同的互斥锁**。

> 如果把一个互斥锁作为参数传给了一个函数，那么在这个函数中对传入的锁的所有操作，都不会对存在于该函数之外的那个原锁产生任何的影响。

死锁，当前程序中的主goroutine，以及启用的那些goroutine都已经被阻塞，这些goroutine可以被统称为用户级的goroutine，这就相当于整个程序都已经停滞不前了。

Go语言运行时系统不允许这种情况出现，当发现所以用户级goroutine都处于等待会抛出如下panic：

```go
fatal error: all goroutines are asleep - deadlock!
```

**Go语言运行时系统自行抛出的panic都属于致命错误，无法被恢复，调用recover函数对它们起不到任何作用，程序死锁，必然崩溃**。

当每个互斥锁都只保护一个临界区或者一组相关临界区可以有效避免死锁。

### Mutex实现

Mutex的架构演进：

1. 初代版本（2008）：Mutex 使用一个 flag 来表示锁是否被持有，实现比较简单；
2. 第二阶段（2011）：后来照顾到新来的 goroutine，所以会让新的 goroutine 也尽可能地先获取到锁；
3. 第三阶段（2015）：照顾新来的和被唤醒的 goroutine；
4. 第四阶段（2016）：但是这样会带来饥饿问题，所以目前又加入了饥饿的解决方案。

#### 初版

通过一个 flag 变量，标记当前的锁是否被某个 goroutine 持有。

- 如果这个 flag 的值是 1，就代表锁已经被持有，那么，其它竞争的 goroutine 只能等待；
- 如果这个 flag 的值是 0，就可以通过 CAS（compare-and-swap，或者 compare-and-set）将这个 flag 设置为 1，标识锁被当前的这个 goroutine 持有了。

```go
// CAS操作，当时还没有抽象出atomic包
func cas(val *int32, old, new int32) bool
func semacquire(*int32)
func semrelease(*int32)

// 互斥锁的结构，包含两个字段
type Mutex struct {
    key  int32 // 锁是否被持有的标识
    sema int32 // 信号量专用，用以阻塞/唤醒goroutine
}

// 保证成功在val上增加delta的值
func xadd(val *int32, delta int32) (new int32) {
    for {
        v := *val
        if cas(val, v, v+delta) {
            return v + delta
        }
    }
    panic("unreached")
}

// 请求锁
func (m *Mutex) Lock() {
    if xadd(&m.key, 1) == 1 { // 标识加1，如果等于1，成功获取到锁
        return
    }
    semacquire(&m.sema) // 否则阻塞等待
}

func (m *Mutex) Unlock() {
    if xadd(&m.key, -1) == 0 { // 将标识减去1，如果等于0，则没有其它等待者
        return
    }
    semrelease(&m.sema) // 唤醒其它阻塞的goroutine
}
```

> CAS 指令将给定的值和一个内存地址中的值进行比较，如果它们是同一个值，就使用新值替换内存地址中的值，这个操作是原子性的，保证这个指令总是基于最新的值进行计算，如果同时有其它线程已经修改了这个值，那么，CAS 会返回失败。**CAS 是实现互斥锁和同步原语的基础。**

Mutex 结构体包含两个字段：

- 字段 key：是一个 flag，用来标识这个排它锁是否被某个 goroutine 所持有，如果 key 大于等于 1，说明这个排它锁已经被持有；
  - 0：锁未被持有
  - 1：锁被持有，没有等待者
  - n：锁被持有，有n-1个等待者
- 字段 sema：是个信号量变量，用来控制等待 goroutine 的阻塞休眠和唤醒。

调用 `Lock` 请求锁的时候，通过 `xadd` 方法进行 CAS 操作，`xadd` 方法通过循环执行 CAS 操作直到成功，保证对 key 加 1 的操作成功完成。

- 如果比较幸运，锁没有被别的 goroutine 持有，那么，`Lock` 方法成功地将 key 设置为 1，这个 goroutine 就持有了这个锁；
- 如果锁已经被别的 goroutine 持有了，那么，当前的 goroutine 会把 key 加 1，而且还会调用 `semacquire` 方法，使用信号量将自己休眠，等锁释放的时候，信号量会将它唤醒。

持有锁的 goroutine 调用 `Unlock` 释放锁时，它会将 key 减 1。

- 如果当前没有其它等待这个锁的 goroutine，这个方法就返回了。
- 但是，如果还有等待此锁的其它 goroutine，那么，它会调用 `semrelease` 方法，利用信号量唤醒等待锁的其它 goroutine 中的一个。

初版的 Mutex 利用 CAS 原子操作，对 key 这个标志量进行设置。key 不仅仅标识了锁是否被 goroutine 所持有，还记录了当前持有和等待获取锁的 goroutine 的数量。

> **`Unlock` 方法可以被任意的 goroutine 调用释放锁，即使是没持有这个互斥锁的 goroutine，也可以进行这个操作。这是因为，Mutex 本身并没有包含持有这把锁的 goroutine 的信息，所以，`Unlock` 也不会对此进行检查。Mutex 的这个设计一直保持至今。**

这样会导致一个问题，其它 goroutine 可以强制释放锁，这是一个非常危险的操作，因为在临界区的 goroutine 可能不知道锁已经被释放了，还会继续执行临界区的业务操作，这可能会带来意想不到的结果，因为这个 goroutine 还以为自己持有锁呢，有可能导致 data race 问题。

所以在使用 Mutex 的时候，必须要保证 goroutine 尽可能不去释放自己未持有的锁，一定要遵循“**谁申请，谁释放**”的原则。在真实的实践中，使用互斥锁的时候，很少在一个方法中单独申请锁，而在另外一个方法中单独释放锁，一般都会在同一个方法中获取锁和释放锁。

以前，经常会基于性能的考虑，及时释放掉锁，所以在一些 `if-else` 分支中加上释放锁的代码，代码看起来很臃肿。而且，在重构的时候，也很容易因为误删或者是漏掉而出现死锁的现象。从 1.14 版本起，Go 对 defer 做了优化，采用更有效的内联方式，取代之前的生成 defer 对象到 defer chain 中，defer 对耗时的影响微乎其微了，所以基本上修改成下面简洁的写法也没问题：

```go
// 以前
type Foo struct {
    mu    sync.Mutex
    count int
}

func (f *Foo) Bar() {
    f.mu.Lock()

    if f.count < 1000 {
        f.count += 3
        f.mu.Unlock() // 此处释放锁
        return
    }

    f.count++
    f.mu.Unlock() // 此处释放锁
    return
}

// 修改后
func (f *Foo) Bar() {
    // Lock和Unlock总是成对出现，不多不漏，代码简洁
    f.mu.Lock()
    defer f.mu.Unlock() // 此处释放所锁

    if f.count < 1000 {
        f.count += 3
        return
    }

    f.count++
    return
}

// 如果临界区只是方法中的一部分，为了尽快释放锁，还是应该第一时间调用 Unlock，而不是一直等到方法返回时才释放。
```

初版的 Mutex 实现有一个问题：请求锁的 goroutine 会排队等待获取互斥锁。虽然这貌似很公平，但是从性能上来看，却不是最优的。因为如果能够把锁交给正在占用 CPU 时间片的 goroutine 的话，那就不需要做上下文的切换，在高并发的情况下，可能会有更好的性能。

#### 第二阶段

对 Mutex 做了一次大的调整，调整后的 Mutex 实现如下：

```go
type Mutex struct {
    state int32 // key 修改为 state
    sema  uint32
}

const (
    mutexLocked = 1 << iota // mutex is locked
    mutexWoken
    mutexWaiterShift = iota
)
```

state 是一个复合型的字段，一个字段包含多个意义，这样可以通过尽可能少的内存来实现互斥锁。所以，state 这一个字段被分成了三部分，代表三个数据：

- mutexWaiters：阻塞等待的waiter数量，剩余的位数代表的是等待此锁的 goroutine 数
- mutexWoken：唤醒标记，第二位代表是否有唤醒的 goroutine
- muteLockedx：持有锁标记，这个字段的第一位（最小的一位）来表示这个锁是否被持有

#### 第三阶段

#### 第四阶段
